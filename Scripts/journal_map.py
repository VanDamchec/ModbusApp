import openpyxl
import ast
import re
from openpyxl.utils import get_column_letter
import os

# --- Определяем структуру таблицы тревог ---
headers = [
    "Категория", "Приоритет", "Тип адреса", "Имя ПЛК (Чтение)", "Тип устройства (Чтение)",
    "Системный тег (Чтение)", "Тег определенный пользователем (Чтение)", "Адрес (Чтение)", "Индекс (Чтение)",
    "Формат данных (Чтение)", "Включить уведомление", "Включить (Уведомление)", "Имя ПЛК (Уведомление)",
    "Тип устройства (уведомление)", "Системный тег (Уведомление)", "Тег определенный пользователем (Уведомление)",
    "Адрес (Уведомление)", "Индекс (Уведомление)", "Условие", "Значение триггера", "Содержание",
    "Использовать библиотеку меток", "Имя метки", "Шрифт", "Цвет", "Подтвержденное значение",
    "Включить звук", "Имя библиотеки звуков", "Индекс звука", "Номер наблюдателя", "Имя ПЛК (Наблюдатель 1)",
    "Тип устройства (Наблюдатель 1)", "Системный тег (Наблюдатель 1)", "Тег определенный пользователем (Наблюдатель 1)",
    "Адрес (Наблюдатель 1)", "Индекс (Наблюдатель 1)", "Формат данных (Наблюдатель 1)", "Номер слова (Наблюдатель 1)",
    "Имя ПЛК (наблюдатель 2)", "Тип устройства (Наблюдатель 2)", "Системный тег (Наблюдатель 2)",
    "Тег определенный пользователем (Наблюдатель 2)", "Адрес (Наблюдатель 2)", "Индекс (Наблюдатель 2)",
    "Формат данных (Наблюдатель 2)", "Номер слова (Наблюдатель 2)", "Имя ПЛК (Наблюдатель 3)",
    "Тип устройства (Наблюдатель 3)", "Системный тег (Наблюдатель 3)", "Тег определенный пользователем (Наблюдатель 3)",
    "Адрес (Наблюдатель 3)", "Индекс (Наблюдатель 3)", "Формат данных (Наблюдатель 3)", "Номер слова (Наблюдатель 3)",
    "Имя ПЛК (Наблюдатель 4)", "Тип устройства (Наблюдатель 4)", "Системный тег (наблюдатель 4)",
    "Тег определенный пользователем (Наблюдатель 4)", "Адрес (Наблюдатель 4)", "Индекс (Наблюдатель 4)",
    "Формат данных (Наблюдатель 4)", "Номер слова (наблюдатель 4)", "Имя ПЛК (Наблюдатель 5)",
    "Тип устройства (Наблюдатель 5)", "Системны тег (Наблюдатель 5)", "Тег определенный пользователем (Наблюдатель 5)",
    "Адрес (Наблюдатель 5)", "Индекс (Наблюдатель 5)", "Формат данных (Наблюдатель 5)", "Номер слова (Наблюдатель 5)",
    "Имя ПЛК (Наблюдатель 6)", "Тип устройства (Наблюдатель 6)", "Системный тег (Наблюдатель 6)",
    "Тег определенный пользователем (Наблюдатель 6)", "Адрес (Наблюдатель 6)", "Индекс (Наблюдатель 6)",
    "Формат данных (Наблюдатель 6)", "Номер слова (Наблюдатель 6)", "Имя ПЛК (Наблюдатель 7)",
    "Тип устройства (Наблюдатель 7)", "Системный тег (Наблюдатель 7)", "Тег определенный пользователем (Наблюдатель 7)",
    "Адрес (Наблюдатель 7)", "Индекс (Наблюдатель 7)", "Формат данных (Наблюдатель 7)", "Номер слова (Наблюдатель 7)",
    "Имя ПЛК (Наблюдатель 8)", "Тип устройства (Наблюдатель 8)", "Системный тег (Наблюдатель 8)",
    "Тег определенный пользователем (Наблюдатель 8)", "Адрес (Наблюдатель 8)", "Индекс (Наблюдатель 8)",
    "Формат данных (Наблюдатель 8)", "Номер слова (Наблюдатель 8)", "Непрерывный звук", "Остановить непрерывный звуковой сигнал",
    "Интервал времени звука", "Отправить eMail при появлении события", "Отправить eMail при исчезновении события",
    "Получатели (Сработало)", "Получатели копий (Сработало)", "Получатели скрытой копии (Сработало)",
    "Тема как событие (Сработало)", "Тема (Сработало)", "Использовать библиотеку меток (Тема)", "Имя метки (Тема)",
    "Открытие (Сработало)", "Использовать библиотеку меток (Открытие)", "Имя метки (Открытие)", "Окончание (Сработало)",
    "Использовать библиотеку меток (Окончание)", "Имя метки (Окончание)", "Скриншот окна", "Получатели (Очищено)",
    "Получатели копии (Очищенно)", "Получатели скрытой копии (Очищенно)", "Тема как событие (Очищено)", "Тема (Очищено)",
    "Использовать библиотеку меток (Тема)", "Имя метки (Тема)", "Открытие (Очищено)", "Использовать библиотеку меток (Открытие)",
    "Имя метки (Открытие)", "Окончание (Очищено)", "Использовать библиотеку меток (Окончание)", "Имя метки (Окончание)",
    "Время задержки", "Динамическое условие", "Имя ПЛК (условие)", "Тип устройства (Условие)", "Системный тег (Условие)",
    "Тег определенный пользователем (условие)", "Адрес (Условие)", "Индекс (Условие)", "Сохранить в истории",
    "Местонахождение", "Имя ПЛК (Местонахождение)", "Тип устройства (Местонахождение)", "Системный тег (Местонахождения)",
    "Тег определенный пользователем (Местонахождение)", "Адрес (Местонахождение)", "Индекс (Местонахождение)",
    "Формат данных (Местонахождение)", "В допуске", "Вне допуска", "Следить", "Использовать таблицу строк",
    "ID секции", "Динамически", "ID строки записи", "ID строки", "Имя ПЛК (ID строки)", "Тип устройства (ID строки)",
    "Системный тег (ID строки)", "Тег определенный пользователем (ID строки)", "Адрес (ID строки)", "Индекс (ID строки)",
    "Формат данных (ID строки)", "Отправить уведомление", "Пройденное время", "Имя ПЛК (Пройденное время)",
    "Тип устройства (Пройденное время)", "Системный тег (Пройденное время)", "Тег определенный пользователем (Пройденное время)",
    "Адрес (Пройденное время)", "Индекс (Пройденное время)", "Формат данных (Пройденное время)", "Цвет фона",
    "Цвет (Цвет фона)", "Подкатегория 1", "Подкатегория 2", "Управление (включить/отключить)", "Установить ON (включить/отключить)",
    "Имя устройства (включить/отключить)", "Тип устройства (включить/отключить)", "Системный тег (включить/отключить)",
    "Пользовательский тег (включить/отключить)", "Адрес (включить/отключить)", "Индекс (включить/отключить)"
]

colors_font = { "Low": "0:0:0", "Middle": "0:0:0", "High": "0:0:0", "Emergency": "255:255:255"}
colors_background = { "Low": "255:255:255", "Middle": "255:255:255", "High": "255:215:0", "Emergency": "165:42:42"}

# --- Функция для генерации файла с заголовками ---
def create_alarm_template(filename):
    """Создает Excel файл с заголовками и метаинформацией."""
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Event" # Имя листа как в оригинале

    # Заполняем метаинформацию
    # VERSION находится в A1, значение 4 в B1
    ws['A1'] = 'VERSION'
    ws['B1'] = 4
    # HARDWARE_VERSION находится в C1, значение 155 в D1
    ws['C1'] = 'HARDWARE_VERSION'
    ws['D1'] = 155

    # Заполняем заголовки в строке 2 (row 2)
    for col_index, header_name in enumerate(headers, start=1): # start=1 т.к. A=1
        ws.cell(row=2, column=col_index, value=header_name)

    # Сохраняем файл
    wb.save(filename)
    print(f"Шаблон файла '{filename}' создан с заголовками.")

# --- Функция для генерации тревог из файла с картой регистров ---
def generate_alarms_from_modbus_map(modbus_map_path, alarm_output_path):
    """
    Читает файл с картой регистров и генерирует тревоги в НОВЫЙ файл тревог.

    Args:
        modbus_map_path (str): Путь к файлу с картой регистров (например, 'modbus_for_panel.xlsx').
        alarm_output_path (str): Путь, куда сохранить файл тревог (например, 'output_alarms.xlsx').
    """
    # Открываем файл с картой регистров
    try:
        wb_modbus = openpyxl.load_workbook(modbus_map_path)
        ws_modbus = wb_modbus.active # Предполагаем, что нужный лист - активный
    except FileNotFoundError:
        print(f"Файл с картой регистров '{modbus_map_path}' не найден.")
        return
    except Exception as e:
        print(f"Ошибка при открытии файла с картой регистров: {e}")
        return

    # --- Создаем НОВЫЙ файл тревог ---
    wb_alarm = openpyxl.Workbook()
    ws_alarm = wb_alarm.active
    ws_alarm.title = "Event"

    # Заполняем метаинформацию нового файла
    ws_alarm['A1'] = 'VERSION'
    ws_alarm['B1'] = 4
    ws_alarm['C1'] = 'HARDWARE_VERSION'
    ws_alarm['D1'] = 155

    # Заполняем заголовки в строке 2 (row 2)
    for col_index, header_name in enumerate(headers, start=1): # start=1 т.к. A=1
        ws_alarm.cell(row=2, column=col_index, value=header_name)

    # Сопоставление столбцов в modbus_map.xlsx с переменными
    COL_ADDRESS_NAME = 1  # Столбец A в modbus_map.xlsx
    COL_NAME_PLC = 2      # Столбец B
    COL_FUNC_TYPE = 3     # Столбец C
    COL_ADDRESS = 4       # Столбец D
    COL_DESCRIPTION = 5   # Столбец E
    COL_DATA_TYPE = 6     # Столбец F
    COL_CATEGORY = 7      # Столбец G
    COL_PRIORITY = 8      # Столбец H
    COL_CONDITION = 9     # Столбец I

    max_modbus_row = ws_modbus.max_row
    print(f"Обнаружено {max_modbus_row - 1} строк данных в файле '{modbus_map_path}' (исключая заголовки).")

    # Начинаем заполнять строки тревог с 3-й строки
    row_index = 3
    processed_count = 0

    for modbus_row_num in range(2, max_modbus_row + 1): # Начинаем с 2, т.к. 1 - заголовки
        # Извлекаем значения из строки modbus_map
        address_name_val = ws_modbus.cell(row=modbus_row_num, column=COL_ADDRESS_NAME).value
        func_type_val = ws_modbus.cell(row=modbus_row_num, column=COL_FUNC_TYPE).value
        address_val = ws_modbus.cell(row=modbus_row_num, column=COL_ADDRESS).value
        description_val = ws_modbus.cell(row=modbus_row_num, column=COL_DESCRIPTION).value
        data_type_val = ws_modbus.cell(row=modbus_row_num, column=COL_DATA_TYPE).value
        category_val = ws_modbus.cell(row=modbus_row_num, column=COL_CATEGORY).value
        priority_val = ws_modbus.cell(row=modbus_row_num, column=COL_PRIORITY).value
        condition_val = ws_modbus.cell(row=modbus_row_num, column=COL_CONDITION).value # Если есть, иначе будет None

        def insert_dist_val(line, val):
            # 2. Проверяем, есть ли [...] в строке
            if re.search(r'\[.*\]', line):
                # Заменяем содержимое [...] на значения
                result = re.sub(r'\[.*?\]', f'{val}', line, count=1)
            else:
                # Квадратных скобок нет — добавляем в конец
                result = line.rstrip() + f'{val}'
            return result

        def extract_dict_and_clean(line):
            # Ищем подстроку в фигурных скобках
            match = re.search(r'\{.*\}', line)
            if not match:
                return line.strip(), {}

            dict_str = match.group(0)
            try:
                # Безопасно преобразуем строку в словарь
                extracted_dict = ast.literal_eval(dict_str)
            except (ValueError, SyntaxError):
                extracted_dict = {}

            # Удаляем фигурные скобки и всё, что внутри, из строки
            cleaned_line = re.sub(r'\s*\{.*\}\s*', '', line).strip()

            return cleaned_line, extracted_dict

        description_val, explan_dict = extract_dict_and_clean(description_val)

        # --- НОВАЯ ЛОГИКА: Проверка категории ---
        # Если category_val - это None, пустая строка или 0, пропускаем строку
        if str(category_val) in ["None",""]: # Это условие верно для None, "", 0, False
            continue # Переходим к следующей строке modbus_map

        # --- Логика определения остальных переменных для тревоги (только если категория была) ---
        name_plc = "PLC"

        # 5. category: Берется из столбца G (COL_CATEGORY), преобразуем в строку
        try:
            category_int = int(category_val) if category_val is not None else 0
            if 0 <= category_int < 256:
                 category = f"{category_int}: Category {category_int}"
            else:
                 print(f"Предупреждение: Категория в строке {modbus_row_num} ({category_val}) вне диапазона 0-255. Установлено в '0: Category 0'.")
                 category = "0: Category 0"
        except (ValueError, TypeError):
            print(f"Предупреждение: Категория в строке {modbus_row_num} ({category_val}) не является числом. Установлено в '0: Category 0'.")
            category = "0: Category 0"

        # 6. priority: Берется из столбца H (COL_PRIORITY)

        # Сопоставление нормализованных значений с каноническим написанием
        PRIORITY_MAP = {
            "low": "Low",
            "middle": "Middle",
            "high": "High",
            "emergency": "Emergency"
        }

        # Предположим, priority_val — это строка из ячейки Excel (может быть None, пустой и т.д.)
        normalized = str(priority_val).strip().lower() if priority_val else ""
        priority = PRIORITY_MAP.get(normalized, "Low")

        # Определяем цвет текста в зависимости от приоритета
        font_color = colors_font[priority]

        # Определяем цвет фона сообщения от приоритета
        color_background = colors_background[priority]

        # Определяем параметр звука для аварий
        on_sound = "True" if priority in ["Emergency", "High"] else "False"

        # 7. type_adress и condition: Определяются из func_type_val и data_type_val
        if func_type_val == "4x_Bit":
            type_adress = "Bit"
            condition = "bt: "
            panel_data_type_for_reading = "Неопределенный"
            value = "0"
        else: # func_type_val == "4x"
            type_adress = "Word"
            condition = "wd: =="
            panel_data_type_for_reading = data_type_val
            value = condition_val

        # --- Формирование словаря alarm_data ---
        if type_adress == "Bit":
            alarm_data = {
                "Категория": category,
                "Приоритет": priority,
                "Тип адреса": type_adress,
                "Имя ПЛК (Чтение)": name_plc,
                "Тип устройства (Чтение)": address_name_val,
                "Тег определенный пользователем (Чтение)": "True",
                "Адрес (Чтение)": address_val,
                "Индекс (Чтение)": "null",
                "Формат данных (Чтение)": panel_data_type_for_reading,
                "Условие": condition,
                "Значение триггера": value,
                "Содержание": description_val,
                "Шрифт": "Droid Sans Fallback",
                "Цвет": font_color,
                "Подтвержденное значение": "11",
                "Индекс звука": "0",
                "Номер наблюдателя": "0",
                "Индекс (Наблюдатель 1)": "null",
                "Включить звук": on_sound,
                "Непрерывный звук": "True",
                "Остановить непрерывный звуковой сигнал": "UNTIL_ACKNOWLEDGED_OR_RECOVERED",
                "Интервал времени звука": "10",
                "Время задержки": "1",
                "Динамическое условие": "0",
                "Имя ПЛК (Наблюдатель 1)": name_plc,
                "Тег определенный пользователем (Наблюдатель 1)": "False",
                "Адрес (Наблюдатель 1)": "",
                "Сохранить в истории": "True",
                "Местонахождение": "Local HMI",
                "Имя ПЛК (Местонахождение)": "LW",
                "Формат данных (Местонахождение)": "16-bit Unsigned",
                "Следить": "True",
                "Отправить уведомление": "True",
                "Пройденное время": "0",
                "Имя ПЛК (Пройденное время)": "LW",
                "Формат данных (Пройденное время)": "16-bit Unsigned",
                "Управление (включить/отключить)": "False",
                "Пользовательский тег (включить/отключить)": "False",
                "Адрес (включить/отключить)": "",

                "Индекс (Условие)": "null",
                "Индекс (Местонахождение)": "null",
                "Адрес (ID строки)": "null",
                "Индекс (Пройденное время)": "null",
                "Цвет фона": "True",
                "Цвет (Цвет фона)": color_background,
                "Установить ON (включить/отключить)": "True",
                "Индекс (включить/отключить)": "null"
            }
        else: # type_adress == "Word"
            alarm_data = {
                "Категория": category,
                "Приоритет": priority,
                "Тип адреса": type_adress,
                "Имя ПЛК (Чтение)": name_plc,
                "Тип устройства (Чтение)": address_name_val,
                "Тег определенный пользователем (Чтение)": "True",
                "Адрес (Чтение)": address_val,
                "Индекс (Чтение)": "null",
                "Формат данных (Чтение)": panel_data_type_for_reading,
                "Условие": condition,
                "Значение триггера": value,
                "Содержание": description_val,
                "Шрифт": "Droid Sans Fallback",
                "Цвет": font_color,
                "Подтвержденное значение": "11",
                "Индекс звука": "0",
                "Номер наблюдателя": "0",
                "Индекс (Наблюдатель 1)": "null",
                "Включить звук": on_sound,
                "Непрерывный звук": "True",
                "Остановить непрерывный звуковой сигнал":"UNTIL_ACKNOWLEDGED_OR_RECOVERED",
                "Интервал времени звука": "10",
                "Время задержки": "1",
                "Динамическое условие": "0",
                "Имя ПЛК (Наблюдатель 1)": name_plc,
                "Тег определенный пользователем (Наблюдатель 1)": "False",
                "Адрес (Наблюдатель 1)": "",
                "Сохранить в истории": "True",
                "Местонахождение": "Local HMI",
                "Имя ПЛК (Местонахождение)": "LW",
                "Формат данных (Местонахождение)": "16-bit Unsigned",
                "В допуске": "0",
                "Вне допуска": "0",
                "Следить": "True",
                "Отправить уведомление": "True",
                "Пройденное время": "0",
                "Имя ПЛК (Пройденное время)": "LW",
                "Формат данных (Пройденное время)": "16-bit Unsigned",
                "Управление (включить/отключить)": "False",
                "Пользовательский тег (включить/отключить)": "False",
                "Адрес (включить/отключить)": "",

                "Индекс (Условие)": "null",
                "Индекс (Местонахождение)": "null",
                "Адрес (ID строки)": "null",
                "Индекс (Пройденное время)": "null",
                "Цвет фона": "True",
                "Цвет (Цвет фона)": color_background,
                "Установить ON (включить/отключить)": "True",
                "Индекс (включить/отключить)": "null"

            }

        # --- Заполнение строки в памяти ---
        try:
            if explan_dict:
                for bit, explan_description in explan_dict.items():
                    # Заполняем строку данными
                    for header_name, value in alarm_data.items():
                        # Найдем индекс столбца для данного заголовка
                        try:
                            col_index = headers.index(header_name)
                        except ValueError:
                            print(f"Предупреждение: Заголовок '{header_name}' не найден в списке. Пропускаем.")
                            continue # Пропускаем, если заголовок не найден

                        if header_name == "Содержание":
                            value = insert_dist_val(value, explan_description)
                            #print(value)

                        if header_name == "Условие":
                            #value = f"{value}{int(not bit)} -> {int(bit)}"
                            value = f"{value}{int(bit)}"
                            #print(value)

                        ws_alarm.cell(row=row_index, column=col_index + 1, value=value) # +1 т.к. cell() принимает 1-based индекс

                    processed_count += 1
                    row_index += 1 # Переходим к следующей строке для тревоги
            else:
                # Заполняем строку данными
                for header_name, value in alarm_data.items():
                    # Найдем индекс столбца для данного заголовка
                    try:
                        col_index = headers.index(header_name)
                    except ValueError:
                        print(f"Предупреждение: Заголовок '{header_name}' не найден в списке. Пропускаем.")
                        continue  # Пропускаем, если заголовок не найден

                    if header_name == "Условие"  and value == "bt: ":
                        value = "bt: 1"

                    ws_alarm.cell(row=row_index, column=col_index + 1,
                                  value=value)  # +1 т.к. cell() принимает 1-based индекс

                processed_count += 1
                row_index += 1  # Переходим к следующей строке для тревоги

        except Exception as e:
            print(f"Ошибка при заполнении строки тревоги из modbus_map строки {modbus_row_num}: {e}")
            continue # Переходим к следующей строке modbus_map

    # --- Сохраняем файл ТОЛЬКО ОДИН РАЗ в конце ---
    try:
        wb_alarm.save(alarm_output_path)
        print(f"Файл тревог '{alarm_output_path}' успешно сохранен.")
    except Exception as e:
        print(f"Ошибка при сохранении файла тревог '{alarm_output_path}': {e}")
        return

    print(f"Генерация тревог завершена. Результат сохранен в '{alarm_output_path}'.")
    print(f"Общее количество добавленных строк: {processed_count}")

# --- Пример использования ---
if __name__ == "__main__":
    modbus_map_file = "modbus_for_panel.xlsx" # Имя файла с результатом convert_modbus_map
    alarm_output_file = "output_alarms.xlsx" # Имя файла, куда будут сохранены сгенерированные тревоги

    # Генерируем тревоги из файла с картой регистров
    # Внутри будет создан новый файл тревог.
    generate_alarms_from_modbus_map(modbus_map_file, alarm_output_file)

    print("Процесс завершен.")
